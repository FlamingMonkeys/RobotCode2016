
package org.usfirst.frc.team3352.robot;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.SampleRobot;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Victor;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * This is a sample program to demonstrate how to use a soft potentiometer and a PID
 * controller to reach and maintain position setpoints on an elevator mechanism.
 *  
 * WARNING: While it may look like a good choice to use for your code if you're inexperienced,
 * don't. Unless you know what you are doing, complex code will be much more difficult under
 * this system. Use IterativeRobot or Command-Based instead if you're new.  
 */
public class Robot extends SampleRobot {
	boolean direction;
	boolean enable;
	double target;
	double angle;
	double kP;
	double error;
	double p;
	double kI;
	double integral;
	double i;
	Shooter shooter;
	Joystick joy;

    public Robot() {
    	shooter = new Shooter();
    	joy = new Joystick(0);
    }

    /**
     * Runs during autonomous.
     */
    public void autonomous() {

    }

    /**
     *  Uses a PIDController and an array of setpoints to switch and maintain elevator 
     *  positions. The elevator setpoint is selected by a joystick button.
     */
    public void operatorControl() {
	
		while (isOperatorControl() && isEnabled()) {
			target = SmartDashboard.getNumber("target",0);
			enable = SmartDashboard.getBoolean("enable",false);
			kP = SmartDashboard.getNumber("kP");
			kI = SmartDashboard.getNumber("kI");
			if(target>angle){
	    		kP = .1;
	    		kI = .01;
	    	}else {
	    		kP = .2;
	    		kI = .02;
	    	}
	    	
	    	error = target - angle;
	    	integral += error;
	    	
	    	if((error<0 && direction)||(error>0&&!direction)) integral = 0;
	    	
	    	p = error*kP;
	    	i = integral*kI;
	
	    	if(enable){
				shooter.setAngle(p+i);
	    	}else{
	    		shooter.setAngle(joy.getRawAxis(1));
	    	}
	    	
			SmartDashboard.putNumber("angle", angle);
			SmartDashboard.putNumber("error", error);
			SmartDashboard.putNumber("integral", integral);
			
	    	angle = shooter.getAngle();
	    	if(error<0) direction = false;
	    
	    }
    }

    /**
     * Runs during test mode.
     */
    public void test() {
    
    }
    
    public void disabled(){
    	SmartDashboard.putBoolean("enable", false);
    	SmartDashboard.putNumber("target", 0);
    	SmartDashboard.putNumber("kP", kP);
    	SmartDashboard.putNumber("kI", kI);
    }
    
    public class Shooter {

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
        private final CANTalon angle = new CANTalon(7);
        private final AnalogGyro gyro = new AnalogGyro(0);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
        public static final double STOW   = 90,
        						   SHOOT  = 45,
        						   INTAKE =  0;
        
        public Shooter(){
        	
        }
        
        public void setAngle(double angle){
        	this.angle.set(angle); //invert to correct direction on practice bot
        }

        public double getAngle(){
        	return gyro.getAngle();
        }

        public void resetGyro(){
        	gyro.reset();
        }
    }
}
